class Joueur {
		//classe représentant un joueur (sa couleur, son nom,ses ressources, ses pièces)
	constructor(color, name) {
		//les paramètres passés au contruceur sont la couleur et le nom; les autre propriétés dépendront de la partie (ressources, pièces)
		this.color = color;
		this.piece = []; //On initialise deux tableaux vides : 'piece', celui des pièces, et prePieces (voir "initPrePieces()")
		this.prePiece = [];
		this.name = name;
		this.gold = config.gold
		this.playedTurns = 0
	}

	initGame(){ //Méthode initialisant le joueur pour une nouvelle partie
		this.mana = config.maxMana;
		this.gold = config.gold;
	}

	startTurn() {
		//méthode permettant de démarrer le tour du joueur: mise à jour de la variable
		//playerTurn, restauration du mana, réinitialisation des cases colorées
		var playerID = getArrayID(joueur,this); //Récupère le numéro du joueur dans le tableau des joueurs
		playerTurn = playerID; //ce numéro devient le nouveau 'playerTurn'
		clearSelectedPiece() //Aucune pièce n'est sélectionnée
		
		this.playedTurns += 1;
		for (let i = 0; i<joueur.length; i++) {if (turn < joueur[i].playedTurns) turn = joueur[i].playedTurns}
		
		this.mana = config.maxMana;
		this.gold += 50 + (turn * 5);
		
		for (var i = 0; i < this.piece.length; i++) {
			this.piece[i].startTurnPre();
		}
		for (var i = 0; i < this.piece.length; i++) { //Une fois qu'on a effectué tous les updatePre, on peut commencer à éxécuter les StartTurn
			this.piece[i].startTurn();
		}

		guiElements.player_arrow.update(); //Met à jour la flèche indiquant le joueur en train de jouer
		selectedPiece = 0;
	}
	
	startAction(mana){
		this.previousMana = this.mana;
		this.mana -= mana;
	}
	
	endAction(){
		let dMana = this.mana - this.previousMana;
		let manaTXT = new Text("msg",config.hud.manaGauge.x + config.hud.manaGauge.w - config.unit * 6 + (dMana > 9) * 3, config.hud.manaGauge.y,dMana,"Arial",config.hud.manaGauge.h,[0,0,255], LEFT, TOP) //Crée un texte bleu "not enough mana"
			applyFadeOut(manaTXT,manaTXT.color,255,0.5) //Le fait disparaître en fondu
	}
	
}

class PrePiece { //Les prePiece sont des objets "prévoyant" une pièce : chaque prePiece indique une future pièce qui sera créée au début de la partie
	//les prePieces qu'un joueur possède avant le début de la partie déterminent donc les pièces qu'il possèdera lorsque la partie se lancera
  constructor(Piece,cx,cy,player, selected){ //Une prePiece ne contient comme attribut que
    this.Piece = Piece; //La classe de la pièce à créer
    this.cx = cx; //La position de la future pièce
    this.cy = cy;
    this.player = player; //Le joueur auquel elle appartient
	this.selected = selected;
  }

  summon(){ //Crée une pièce (réelle) à partir de cette prePiece
	if (this.Piece.constructor.name == "Array"){	
		if (typeof this.selected != "number") {
			console.warn("No specified selection for the multiPiece at (" + this.cx + ";" + this.cy+ ") of player " + this.player);
			this.selected = 0
		}
		joueur[this.player].piece.push(new this.Piece[this.selected](this.cx,this.cy,this.player))
	}else{
		joueur[this.player].piece.push(new this.Piece(this.cx,this.cy,this.player))
	}
  }

}

class Spell { //Classe définissant un sort d'une pièce
		constructor(name,manaCost,cooldown,img,helpImg,baseLocked,piece,onUsed,effect,getRange,condition){
		this.name = name; //nom
		this.manaCost = manaCost; //coût en mana
		this.img = img; //icône
		this.helpImg = helpImg; //*non-utilisé*
		this.locked = baseLocked; //disponibilité au début de la partie : true si bloqué, un nombre si on veut le bloquer jusqu'à ce que la pièce atteigne le niveau correspondant
		this.onUsed = onUsed; //fonction éxécutée au clic sur l'icône
		this.effect = effect; //effet du sort : peut être lancé directement lors du clic, ou après
		this.getRange = getRange; //fonction donnant les cases sur lesquelles le spell peut agir (s'il agit sur des cases définies)
		this.condition = condition //fonction déterminant si le lancement du spell est possible
		this.piece = piece; //pièce propriétaire
		this.cooldown = cooldown; //délai de récupération
		this.actualCooldown = 0; //récupération actuelle
	}

	cast(arg,cost = this.manaCost, cd = this.cooldown){ //lance le spell (sera a priori appelée à un moment où un autre dans onUsed() ) :
		if (this.spendMana(cost)){
			this.effect(arg) //éxécute l'effet
			this.startCooldown(cd)
		}
	}
  
	unlock(){
		this.locked = false
	}
	
	spendMana(cost = this.manaCost){
		if (typeof cost != "number" || !joueur || joueur[this.piece.player].mana >= cost){ //si le joueur a assez de mana (ou si aucun joueur n'est défini)
			if (joueur) joueur[this.piece.player].mana -= cost; //retire le mana au joueur s'il est défini
			return true
		}
		return false
	}
	
	startCooldown(cd = this.cooldown){
		if (typeof cd == "number") this.actualCooldown = cd //indique qu'il reste un certain nombre de tour avant de pouvoir l'utiliser
	}
}

class TogglableSpell extends Spell {
	constructor(name, manaCost, cooldown, img, helpImg, baseLocked, piece, onUsed, cast, getRange, condition, effect, callbacks){
	
		onUsed = onUsed || function(){
			if (!this.active) this.cast(null, undefined, null);
			else {
				this.disable()
			}
		}
		
		
		cast = cast || function(){
			if (!this.active) {
				this.toggle()
			}
			
		}
		
		super(name,manaCost,cooldown,img,helpImg,baseLocked,piece,onUsed,cast,getRange,condition)
		this.pEffect = effect;
		this.pEffect.spell = this;
		this.pEffect.aEndEffect = this.pEffect.endEffect
		this.pEffect.endEffect = function(piece, type){
			this.spell.active = false
			this.spell.startCooldown()
			if (this.aEndEffect) this.aEndEffect(piece, type)
		}
		this.callbacks = callbacks;
	}
	
	toggle(){
		this.active = true;
		if (this.callbacks && this.callbacks.toggle) this.callbacks.toggle.bind(this)()
		this.pEffect.init()
	
	}
	
	disable(){
		this.active = false
		if (this.callbacks && this.callbacks.disable) this.callbacks.disable.bind(this)()
		this.pEffect.end("disable")
	}
}

class Item{
	constructor(name,img,cost,effects = [],onBuying,require){
		this.name = name
		this.img = img
		this.cost = cost
		this.effects = effects || []
		this.require = require
		this.onBuying = onBuying
	}
	
	obtain(piece){
		piece.items.push(this);
		piece.items[this.name] = true
		if (this.onBuying) this.onBuying(piece)
		for (let i = 0; i < this.effects.length; i++){
				this.effects[i](piece)
		}	
	}
	
	isBuyable(piece){
		if (joueur[piece.player].gold < this.cost) return false
		if (this.require && !this.require(piece)) return false
		return true
	}
	
	buy(piece){
		if (this.isBuyable(piece)){
			this.obtain(piece)
			joueur[piece.player].gold -= this.cost;
			return true
		}
	}
	
}

class Effect { //classe représentant les effets sur la durée appliqués aux pièces. A ajouter au tableau .effect d'une pièce pour lui appliquer un effet
	//un effet contient une fonction qui sera appelée à chaque tour, pour s'assurer que l'effet est présent de manière continue, jusqu'à un certain nombre de tour
	constructor(piece,duration,permEffect = 0,endEffect = 0,turnEffect = 0,direct = true,view, important){
		this.piece = piece; //pièce sur laquelle l'effet agira
		this.turnEffect = turnEffect; //effet continu : sera lancé à chaque début de tour (souvent pour modifier les stats après leur réinitialisation)
		this.endEffect = endEffect; //fcontion à éxécuter lorsque l'effet se termine
		this.duration = duration; //durée de l'effet en tours
		this.remaining = duration;
		this.permEffect = permEffect;
		this.view = view;
		this.direct = direct;
		if (view && !view.name && !view.icon) delete this.view;
		this.important = important;
	}

	init(){
		this.piece.effects.push(this)
		if (this.direct && this.permEffect) this.permEffect(this.piece); //si on a précisé que l'effet était présent dès son applicaiton, on lance son effet continu
	}
	
	apply(){ //applique l'effet
		if (this.permEffect) this.permEffect(this.piece); //lance sa fonction d'effet continu
	}
	
	startTurn(){ //sera lancé au début de chaque tour
		this.remaining--;
		if (this.remaining < 1){ //s'il arrive à sa fin
			this.end()
		}else{
			if (this.turnEffect) this.turnEffect(this.piece);
			this.apply()
		}
	}

	end(type){
		if(this.endEffect) this.endEffect(this.piece, type); //lance la fonction de fin
			this.destroy(); //puis le supprime
	}
	
	destroy(){
		this.piece.effects.spliceItem(this); //supprime l'effet du tableau piece.effects
		updatePieces();
	}
}